# NetworkPolicy in Kubernetes

## What is a NetworkPolicy?

A **NetworkPolicy** is a Kubernetes resource used to **control network traffic between Pods and/or external endpoints** at the IP address or port level.

In simple terms:

* It acts like a **firewall for Pods**
* It defines **who can talk to whom**, and **on which ports**

NetworkPolicies are implemented by the **Container Network Interface (CNI)** plugin (like Calico, Cilium, Weave). If the CNI does not support NetworkPolicy, these rules do nothing.

---

## Default Network Behavior (Without NetworkPolicy)

By default, Kubernetes networking follows an **open network model**.

### Default Rules

* All Pods can communicate with **all other Pods** across namespaces
* All inbound traffic to Pods is **allowed**
* All outbound traffic from Pods is **allowed**
* No network isolation exists by default

### Example (No NetworkPolicy)

```
Pod A (frontend)  ---> Pod B (backend)   âœ… Allowed
Pod A (frontend)  ---> Pod C (database)  âœ… Allowed
Any Pod           ---> Any Pod           âœ… Allowed
```

This is convenient for development but **unsafe for production**.

---

## Why NetworkPolicy is Needed

Without NetworkPolicy:

* A compromised Pod can talk to **any other Pod**
* No isolation between frontend, backend, and database
* Hard to enforce **Zero Trust networking**

With NetworkPolicy:

* You explicitly allow required traffic
* Everything else is **denied by default**

---

## How NetworkPolicy Works

A NetworkPolicy:

* Selects Pods using **labels**
* Defines rules for:

  * **Ingress** (incoming traffic)
  * **Egress** (outgoing traffic)
* Rules are **additive** (multiple policies can apply)

Important:

> Traffic is only restricted **after a Pod is selected by a NetworkPolicy**

---

## Key Components of NetworkPolicy

| Field       | Purpose                       |
| ----------- | ----------------------------- |
| podSelector | Selects target Pods           |
| policyTypes | Ingress / Egress              |
| ingress     | Allowed incoming traffic      |
| egress      | Allowed outgoing traffic      |
| from / to   | Traffic source or destination |
| ports       | Allowed ports                 |

---

## Example Scenario

### Setup

* Namespace: `app`
* Pods:

  * frontend (label: app=frontend)
  * backend (label: app=backend)
  * database (label: app=db)

Goal:

* Frontend âœ Backend âœ…
* Backend âœ Database âœ…
* Frontend âœ Database âŒ

---

## Step 1: Default Deny All Ingress

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: app
spec:
  podSelector: {}
  policyTypes:
  - Ingress
```

### Effect

* Blocks **all incoming traffic** to all Pods in namespace
* Outgoing traffic still allowed

---

## Step 2: Allow Frontend âœ Backend

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: app
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
```

### Effect

* Only frontend Pods can access backend on port 8080

---

## Step 3: Allow Backend âœ Database

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-to-db
  namespace: app
spec:
  podSelector:
    matchLabels:
      app: db
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend
    ports:
    - protocol: TCP
      port: 5432
```

### Effect

* Only backend Pods can talk to database on port 5432

---

## Egress NetworkPolicy Example

Allow backend Pods to access external APIs only on HTTPS.

```
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-egress-https
  namespace: app
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Egress
  egress:
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
    ports:
    - protocol: TCP
      port: 443
```

---

## Important Notes

* NetworkPolicy works at **Layer 3/4** (IP + Port)
* It does **not** inspect HTTP paths or headers
* Policies are namespace-scoped
* If no NetworkPolicy selects a Pod â†’ traffic is unrestricted

---

## Summary

* NetworkPolicy controls Pod-to-Pod and Pod-to-external traffic
* Default Kubernetes networking is **allow-all**
* NetworkPolicy enables **secure, least-privilege networking**
* Always start with **default deny**, then allow required traffic

---

## One-Line Definition

> NetworkPolicy is a Kubernetes firewall mechanism that defines how Pods are allowed to communicate with each other and external services.
---
# ğŸŒ Kubernetes NetworkPolicy â€“ Ingress Rules Explained (All Cases)

This guide explains **Ingress rules in NetworkPolicy** covering:

* same namespace traffic
* different namespace traffic
* podSelector vs namespaceSelector
* combined selectors
* common mistakes & cautions ğŸš¨

---

## ğŸ§  What is an Ingress Rule?

An **Ingress rule** defines **who is allowed to send traffic INTO a Pod**.

Without NetworkPolicy:

> ğŸ”“ All Pods can talk to all Pods

With NetworkPolicy:

> ğŸ” Only explicitly allowed traffic is permitted

---

## âš ï¸ VERY IMPORTANT DEFAULT BEHAVIOR

The moment you apply **any Ingress NetworkPolicy** to a Pod:

ğŸš« **All ingress traffic is DENIED by default**

You must explicitly allow:

* which Pods ğŸ‘¥
* from which Namespaces ğŸ—‚ï¸
* on which Ports ğŸ”¢

---

# ğŸ§© Ingress Rule Building Blocks

Ingress rules use **three selectors**:

| Selector            | Meaning                         |
| ------------------- | ------------------------------- |
| `podSelector`       | Allow Pods with matching labels |
| `namespaceSelector` | Allow Pods from namespaces      |
| `ipBlock`           | Allow CIDR IP ranges            |

---

# ğŸ“Œ CASE 1: Allow Traffic from SAME Namespace (Specific Pods)

### ğŸ¯ Use Case

Frontend Pods â†’ Backend Pods **inside same namespace**

---

### Backend NetworkPolicy

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend
  namespace: app
spec:
  podSelector:
    matchLabels:
      role: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 8080
```

### ğŸ” What this allows

* âœ… frontend â†’ backend (same namespace)
* âŒ anything else â†’ backend

---

# ğŸ“Œ CASE 2: Allow ALL Pods in SAME Namespace

### ğŸ¯ Use Case

Internal microservices communication

```yaml
spec:
  podSelector:
    matchLabels:
      role: backend
  ingress:
  - from:
    - podSelector: {}
```

ğŸ§  `podSelector: {}` = all Pods **in the same namespace only**

---

# ğŸ“Œ CASE 3: Allow Traffic from DIFFERENT Namespace (All Pods)

### ğŸ¯ Use Case

Monitoring namespace scraping application metrics

```yaml
spec:
  podSelector:
    matchLabels:
      role: backend
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
```

ğŸ”‘ Namespace must have this label:

```bash
kubectl label namespace monitoring name=monitoring
```

---

# ğŸ“Œ CASE 4: Allow Specific Pods from a DIFFERENT Namespace

### ğŸ¯ Use Case

Ingress Controller â†’ App namespace

```yaml
ingress:
- from:
  - namespaceSelector:
      matchLabels:
        name: ingress-nginx
    podSelector:
      matchLabels:
        app: ingress-nginx
```

ğŸ§  **AND condition**:

* Namespace must match
* Pod labels must match

---

# ğŸ“Œ CASE 5: Allow from SAME + DIFFERENT Namespace (Multiple Rules)

```yaml
ingress:
- from:
  - podSelector:
      matchLabels:
        role: frontend
- from:
  - namespaceSelector:
      matchLabels:
        name: monitoring
```

Rules are evaluated as **OR conditions** âœ…

---

# ğŸ“Œ CASE 6: Allow Traffic from IP Range (External Clients)

```yaml
ingress:
- from:
  - ipBlock:
      cidr: 10.0.0.0/16
      except:
      - 10.0.5.0/24
```

---

# ğŸš¨ MOST COMMON MISTAKES (READ CAREFULLY)

## âŒ Mistake 1: Forgetting `policyTypes`

```yaml
policyTypes:
- Ingress
```

Without this, behavior can be confusing or incomplete.

---

## âŒ Mistake 2: Assuming namespaceSelector works without labels

Namespaces **do NOT have useful labels by default** â—

You must label them explicitly:

```bash
kubectl label ns prod env=prod
```

---

## âŒ Mistake 3: Expecting `podSelector: {}` to include other namespaces

ğŸš« Wrong assumption

```yaml
podSelector: {}
```

âœ… Only allows Pods **inside same namespace**

---

## âŒ Mistake 4: Blocking DNS accidentally

If you deny ingress without allowing DNS:

* Services break
* Pods canâ€™t resolve names

### Allow kube-dns explicitly

```yaml
ingress:
- from:
  - namespaceSelector:
      matchLabels:
        kubernetes.io/metadata.name: kube-system
    podSelector:
      matchLabels:
        k8s-app: kube-dns
  ports:
  - port: 53
    protocol: UDP
```

---

## âŒ Mistake 5: NetworkPolicy applied but CNI doesnâ€™t support it

ğŸš« NetworkPolicy works ONLY if CNI supports it:

| CNI     | Supported |
| ------- | --------- |
| Calico  | âœ…         |
| Cilium  | âœ…         |
| Weave   | âœ…         |
| Flannel | âŒ         |

---

# ğŸ§  Mental Model (Interview Gold â­)

* `podSelector` â†’ **WHO** (Pods)
* `namespaceSelector` â†’ **WHERE FROM** (Namespace)
* `ports` â†’ **HOW** (Protocol/Port)

AND inside a rule, OR across rules

---

## ğŸ§  One-Line Interview Answer

> **Ingress NetworkPolicy defines who can send traffic to a Pod. Once applied, all ingress is denied by default, and traffic must be explicitly allowed using podSelector, namespaceSelector, or ipBlock with careful attention to namespace labels and DNS access.**

---

ğŸ‰ You now have a complete, production-grade understanding of **Ingress NetworkPolicy rules and pitfalls** ğŸ”
