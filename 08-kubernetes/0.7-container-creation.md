# Kubernetes Container Creation: Full Flow (API â†’ CRI â†’ Runtime)

This document explains **how container creation information flows in Kubernetes**, how **state is updated**, and **how CRI knows how to create containers**, with a **complete end-to-end flow diagram**.

---

## High-Level Idea

Kubernetes follows a **desired state model**:

* You declare *what you want* (Pod spec)
* Kubernetes continuously works to make reality match that state

**Kubernetes never creates containers directly.**
It delegates this to the **kubelet**, which uses the **Container Runtime Interface (CRI)**.

---

## Main Components Involved

| Component      | Role                                       |
| -------------- | ------------------------------------------ |
| kubectl        | Sends user intent (YAML)                   |
| kube-apiserver | Validates requests & exposes cluster state |
| etcd           | Stores desired & current state             |
| scheduler      | Assigns Pods to nodes                      |
| kubelet        | Node agent enforcing desired state         |
| CRI runtime    | Creates containers (containerd / CRI-O)    |
| OCI runtime    | Low-level container execution (runc)       |

---

## Complete Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  kubectl â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ 1. kubectl apply -f pod.yaml
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ kube-apiserverâ”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 2. Store Pod spec (desired state)
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  etcd    â”‚  â† Source of Truth
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 3. Scheduler watches for unscheduled Pods
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  scheduler    â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 4. Assign nodeName
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  etcd    â”‚  â† Pod now bound to a node
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 5. Kubelet watches API server
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   kubelet     â”‚ (on worker node)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 6. Pod not running â†’ must create it
     â”‚
     â”‚ 7. CRI gRPC calls
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CRI Runtime  â”‚ (containerd / CRI-O)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 8. Generate OCI spec
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OCI Runtime   â”‚ (runc)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚ 9. Linux namespaces, cgroups
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Container    â”‚ (running process)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 10. Status reported back
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  etcd    â”‚ â† Actual state updated
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Step-by-Step Detailed Flow

### 1. User Submits Pod Definition

```bash
kubectl apply -f nginx.yaml
```

* kubectl sends request to kube-apiserver
* API server validates and persists the Pod spec

ğŸ“Œ **Only desired state exists at this point**

---

### 2. Desired State Stored in etcd

```yaml
spec:
  containers:
  - name: nginx
    image: nginx
```

* No container exists yet
* etcd stores *what should exist*

---

### 3. Scheduler Assigns a Node

* Scheduler watches etcd
* Picks a suitable node
* Updates Pod:

```yaml
spec:
  nodeName: worker-node-1
```

---

### 4. Kubelet Detects Assigned Pod

* Kubelet on `worker-node-1` watches API server
* Sees a Pod assigned to itself
* Compares:

  * Desired state (Pod spec)
  * Actual state (no containers running)

ğŸ“Œ **Gap detected â†’ action required**

---

## How CRI Knows How to Create Containers

### 5. Kubelet Uses CRI (gRPC)

Kubelet calls CRI APIs such as:

```
RunPodSandbox()
CreateContainer()
StartContainer()
```

* CRI is a **standard interface**, not an implementation
* Any runtime implementing CRI can be used

---

### 6. PodSandbox Creation (Very Important)

Before containers start:

* Network namespace created
* Pod IP allocated
* Shared namespaces prepared

This ensures:

* All containers in a Pod share networking

---

### 7. Container Creation via OCI

CRI runtime:

1. Pulls image
2. Converts Pod spec â†’ OCI spec
3. Invokes OCI runtime (runc)

Example OCI intent:

```json
{
  "args": ["nginx", "-g", "daemon off;"],
  "env": ["PORT=80"]
}
```

---

### 8. OCI Runtime Executes Container

* Linux kernel creates:

  * Namespaces
  * cgroups
* Process starts inside container

ğŸ“Œ **Now the container is actually running**

---

## State Update Back to Kubernetes

### 9. Kubelet Reports Actual State

```yaml
status:
  phase: Running
  containerStatuses:
  - name: nginx
    state:
      running:
        startedAt: <timestamp>
```

* API server stores this in etcd
* `kubectl get pods` shows correct status

---

## Continuous Reconciliation Loop

```
Desired State (etcd)
        â†“
Kubelet Reconciliation
        â†“
CRI + Runtime Execution
        â†“
Actual State Reported
        â†“
Back to etcd
```

This loop runs **continuously**.

---

## One-Line Mental Model

> **etcd stores intent â†’ kubelet enforces intent â†’ CRI executes intent â†’ kubelet reports reality**

---

## Why This Architecture Matters

* Runtime-agnostic (Docker is not required)
* Self-healing (crash â†’ recreate)
* Clear separation of concerns
* Strong observability and control

---

## Summary

* Kubernetes manages *state*, not containers
* CRI is the bridge between Kubernetes and runtimes
* OCI runtimes interact directly with the Linux kernel
* Kubelet is the key enforcer of desired state

---

End of document.
