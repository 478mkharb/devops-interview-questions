# DNS in Kubernetes

This document explains **how DNS works inside a Kubernetes cluster** and **what CoreDNS does**, in a **simple, non‑confusing flow**.

---

## Why DNS Is Needed in Kubernetes

* Pods get **dynamic IPs**
* Pods are **created and destroyed frequently**
* Applications must communicate using **names**, not IPs

Kubernetes solves this using **CoreDNS**.

---

## What Is CoreDNS (In One Line)

**CoreDNS is the cluster’s DNS server that converts Kubernetes Service names into IP addresses.**

It runs **inside the cluster** as Pods.

---

## Where CoreDNS Runs

* Namespace: `kube-system`
* Runs as a **Deployment**
* Exposed using a **Service called `kube-dns`**

You **do not create CoreDNS Pods manually**.

---

## Example Used in This Document

| Component          | Value                               |
| ------------------ | ----------------------------------- |
| Source Pod         | `frontend`                          |
| Target Service     | `backend`                           |
| Namespace          | `default`                           |
| Service Name       | `backend.default.svc.cluster.local` |
| CoreDNS Service IP | `10.96.0.10`                        |
| Backend Pod IP     | `10.244.1.15`                       |

---

## Simple DNS Resolution Flow (Step‑by‑Step)

### Step 1: Application Makes a Request

Inside `frontend` Pod:

```bash
curl http://backend
```

The application asks:

> “What is the IP address of `backend`?”

---

### Step 2: Pod Sends DNS Query

Every Pod has this file:

```text
/etc/resolv.conf
nameserver 10.96.0.10
search default.svc.cluster.local svc.cluster.local
```

So the DNS query is sent to:

```text
10.96.0.10  (kube-dns Service)
```

---

### Step 3: CoreDNS Handles the Query

* The query reaches **CoreDNS**
* CoreDNS already knows about Services
* It does **not call the API every time**

CoreDNS finds:

```text
backend.default → 10.96.120.45
```

---

### Step 4: DNS Response Is Returned

CoreDNS replies to the Pod:

```text
backend.default.svc.cluster.local = 10.96.120.45
```

---

### Step 5: Traffic Goes to the Service

Now the request flows like this:

```text
frontend Pod → 10.96.120.45 (Service IP)
```

---

### Step 6: Service Sends Traffic to Pod

* Service selects a backend Pod
* kube‑proxy routes traffic

```text
10.96.120.45 → 10.244.1.15 (backend Pod)
```

Request is served.

---

## Full Flow Diagram

```text
frontend Pod
   |
   | curl http://backend
   |
   | DNS query
   v
kube-dns Service (10.96.0.10)
   |
   | DNS handled by CoreDNS
   v
Service IP returned
10.96.120.45
   |
   | HTTP request
   v
kube-proxy
   |
   | forwards traffic
   v
backend Pod (10.244.1.15)
```

---

## How CoreDNS Knows About Services

CoreDNS continuously watches:

* Services
* Endpoints / EndpointSlices

When a Service or Pod changes, **DNS records update automatically**.

---

## Headless Service (Quick Note)

If a Service has:

```yaml
clusterIP: None
```

DNS returns **Pod IPs directly**, not a Service IP.

Used mainly by **StatefulSets**.

---

## Key Points to Remember

* CoreDNS is **installed automatically**
* Pods use DNS via **kube-dns Service**
* DNS always resolves **Service names → IPs**
* CoreDNS is critical for **service‑to‑service communication**

---

### One‑Line Summary

> Pod → CoreDNS → Service IP → Pod
